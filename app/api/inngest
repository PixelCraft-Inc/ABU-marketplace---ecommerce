package inngest

import (
    "context"
    "encoding/json"
    "fmt"
    "io"
    "log"
    "net/http"
    "time"
)

// Event represents a minimal shape of an incoming Inngest event.
// Adjust fields to match the events you expect.
type Event struct {
    ID        string                 `json:"id"`
    Name      string                 `json:"name"`
    Data      map[string]interface{} `json:"data"`
    CreatedAt *time.Time             `json:"created_at,omitempty"`
}

// NewMux returns an http.ServeMux with the Inngest webhook endpoint registered.
// Use it in your server like: http.ListenAndServe(":8080", inngest.NewMux())
func NewMux() *http.ServeMux {
    mux := http.NewServeMux()
    mux.HandleFunc("/api/inngest", handleWebhook)
    return mux
}

func handleWebhook(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
        return
    }

    ctx := r.Context()
    body, err := io.ReadAll(r.Body)
    if err != nil {
        log.Printf("inngest: read body error: %v", err)
        http.Error(w, "bad request", http.StatusBadRequest)
        return
    }
    defer r.Body.Close()

    var ev Event
    if err := json.Unmarshal(body, &ev); err != nil {
        log.Printf("inngest: json unmarshal error: %v", err)
        http.Error(w, "invalid json", http.StatusBadRequest)
        return
    }

    // Basic validation
    if ev.ID == "" || ev.Name == "" {
        http.Error(w, "missing event id or name", http.StatusBadRequest)
        return
    }

    // Acknowledge immediately to the caller
    w.WriteHeader(http.StatusAccepted)
    _, _ = w.Write([]byte("accepted"))

    // Process asynchronously so the HTTP response is quick.
    go func() {
        // create a cancellable context with timeout for background work
        ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
        defer cancel()

        if err := processEvent(ctx, &ev); err != nil {
            log.Printf("inngest: processing error for event %s (%s): %v", ev.ID, ev.Name, err)
        } else {
            log.Printf("inngest: processed event %s (%s)", ev.ID, ev.Name)
        }
    }()
}

func processEvent(ctx context.Context, ev *Event) error {
    // Add routing for event names you care about.
    switch ev.Name {
    case "order.created":
        return handleOrderCreated(ctx, ev)
    case "user.signed_up":
        return handleUserSignedUp(ctx, ev)
    default:
        // unknown events can be ignored or logged
        log.Printf("inngest: unhandled event name: %s", ev.Name)
        return nil
    }
}

func handleOrderCreated(ctx context.Context, ev *Event) error {
    // Example: extract some fields from ev.Data and simulate work.
    orderID := fmt.Sprintf("%v", ev.Data["order_id"])
    amount := fmt.Sprintf("%v", ev.Data["amount"])
    log.Printf("handleOrderCreated: order_id=%s amount=%s", orderID, amount)

    // Simulate doing background work; replace with real logic (DB, queues, etc).
    select {
    case <-time.After(500 * time.Millisecond):
        // pretend success
        return nil
    case <-ctx.Done():
        return ctx.Err()
    }
}

func handleUserSignedUp(ctx context.Context, ev *Event) error {
    userID := fmt.Sprintf("%v", ev.Data["user_id"])
    email := fmt.Sprintf("%v", ev.Data["email"])
    log.Printf("handleUserSignedUp: user_id=%s email=%s", userID, email)

    // Add real onboarding work here.
    select {
    case <-time.After(200 * time.Millisecond):
        return nil
    case <-ctx.Done():
        return ctx.Err()
    }
}